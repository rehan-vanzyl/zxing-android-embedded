diff --git a/src-orig/com/google/zxing/client/android/CaptureActivityHandler.java b/src/com/google/zxing/client/android/CaptureActivityHandler.java
index 9ec3ecf..e30f43a 100755
--- a/src-orig/com/google/zxing/client/android/CaptureActivityHandler.java
+++ b/src/com/google/zxing/client/android/CaptureActivityHandler.java
@@ -77,58 +77,29 @@ public final class CaptureActivityHandler extends Handler {
 
   @Override
   public void handleMessage(Message message) {
-    int switchValue = message.what;
-    if(switchValue == R.id.zxing_restart_preview) {
-        restartPreviewAndDecode();
-      } else if(switchValue == R.id.zxing_decode_succeeded) {
-        state = State.SUCCESS;
-        Bundle bundle = message.getData();
-        Bitmap barcode = null;
-        float scaleFactor = 1.0f;
-        if (bundle != null) {
-          byte[] compressedBitmap = bundle.getByteArray(DecodeThread.BARCODE_BITMAP);
-          if (compressedBitmap != null) {
-            barcode = BitmapFactory.decodeByteArray(compressedBitmap, 0, compressedBitmap.length, null);
-            // Mutable copy:
-            barcode = barcode.copy(Bitmap.Config.ARGB_8888, true);
-          }
-          scaleFactor = bundle.getFloat(DecodeThread.BARCODE_SCALED_FACTOR);          
-        }
-        activity.handleDecode((Result) message.obj, barcode, scaleFactor);
-      } else if(switchValue == R.id.zxing_decode_failed) {
-        // We're decoding as fast as possible, so when one decode fails, start another.
-        state = State.PREVIEW;
-        cameraManager.requestPreviewFrame(decodeThread.getHandler(), R.id.zxing_decode);
-      } else if(switchValue == R.id.zxing_return_scan_result) {
-        activity.setResult(Activity.RESULT_OK, (Intent) message.obj);
-        activity.finish();
-      } else if(switchValue == R.id.zxing_launch_product_query) {
-        String url = (String) message.obj;
-
-        Intent intent = new Intent(Intent.ACTION_VIEW);
-        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
-        intent.setData(Uri.parse(url));
-
-        ResolveInfo resolveInfo =
-            activity.getPackageManager().resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
-        String browserPackageName = null;
-        if (resolveInfo != null && resolveInfo.activityInfo != null) {
-          browserPackageName = resolveInfo.activityInfo.packageName;
-          Log.d(TAG, "Using browser in package " + browserPackageName);
+    if (message.what == R.id.zxing_decode_succeeded) {
+      state = State.SUCCESS;
+      Bundle bundle = message.getData();
+      Bitmap barcode = null;
+      float scaleFactor = 1.0f;
+      if (bundle != null) {
+        byte[] compressedBitmap = bundle.getByteArray(DecodeThread.BARCODE_BITMAP);
+        if (compressedBitmap != null) {
+          barcode = BitmapFactory.decodeByteArray(compressedBitmap, 0, compressedBitmap.length, null);
+          // Mutable copy:
+          barcode = barcode.copy(Bitmap.Config.ARGB_8888, true);
         }
+        scaleFactor = bundle.getFloat(DecodeThread.BARCODE_SCALED_FACTOR);
+      }
+      activity.handleDecode((Result) message.obj, barcode, scaleFactor);
 
-        // Needed for default Android browser / Chrome only apparently
-        if ("com.android.browser".equals(browserPackageName) || "com.android.chrome".equals(browserPackageName)) {
-          intent.setPackage(browserPackageName);
-          intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-          intent.putExtra(Browser.EXTRA_APPLICATION_ID, browserPackageName);
-        }
+    } else if (message.what == R.id.zxing_decode_failed) {// We're decoding as fast as possible, so when one decode fails, start another.
+      state = State.PREVIEW;
+      cameraManager.requestPreviewFrame(decodeThread.getHandler(), R.id.zxing_decode);
 
-        try {
-          activity.startActivity(intent);
-        } catch (ActivityNotFoundException ignored) {
-          Log.w(TAG, "Can't find anything to handle VIEW of URI " + url);
-        }
+    } else if (message.what == R.id.zxing_return_scan_result) {
+      activity.setResult(Activity.RESULT_OK, (Intent) message.obj);
+      activity.finish();
     }
   }
 
diff --git a/src-orig/com/google/zxing/client/android/PreferencesActivity.java b/src/com/google/zxing/client/android/PreferencesActivity.java
index 0644362..cfcdc05 100755
--- a/src-orig/com/google/zxing/client/android/PreferencesActivity.java
+++ b/src/com/google/zxing/client/android/PreferencesActivity.java
@@ -16,57 +16,21 @@
 
 package com.google.zxing.client.android;
 
-import android.app.Activity;
-import android.os.Bundle;
-
 /**
  * The main settings activity.
  *
  * @author dswitkin@google.com (Daniel Switkin)
  * @author Sean Owen
  */
-public final class PreferencesActivity extends Activity {
-
-  public static final String KEY_DECODE_1D_PRODUCT = "zxing_preferences_decode_1D_product";
-  public static final String KEY_DECODE_1D_INDUSTRIAL = "zxing_preferences_decode_1D_industrial";
-  public static final String KEY_DECODE_QR = "zxing_preferences_decode_QR";
-  public static final String KEY_DECODE_DATA_MATRIX = "zxing_preferences_decode_Data_Matrix";
-  public static final String KEY_DECODE_AZTEC = "zxing_preferences_decode_Aztec";
-  public static final String KEY_DECODE_PDF417 = "zxing_preferences_decode_PDF417";
-
-  public static final String KEY_CUSTOM_PRODUCT_SEARCH = "zxing_preferences_custom_product_search";
-
+public final class PreferencesActivity {
   public static final String KEY_PLAY_BEEP = "zxing_preferences_play_beep";
   public static final String KEY_VIBRATE = "zxing_preferences_vibrate";
-  public static final String KEY_COPY_TO_CLIPBOARD = "zxing_preferences_copy_to_clipboard";
   public static final String KEY_FRONT_LIGHT_MODE = "zxing_preferences_front_light_mode";
-  public static final String KEY_BULK_MODE = "zxing_preferences_bulk_mode";
-  public static final String KEY_REMEMBER_DUPLICATES = "zxing_preferences_remember_duplicates";
-  public static final String KEY_ENABLE_HISTORY = "zxing_preferences_history";
-  public static final String KEY_SUPPLEMENTAL = "zxing_preferences_supplemental";
   public static final String KEY_AUTO_FOCUS = "zxing_preferences_auto_focus";
-  public static final String KEY_INVERT_SCAN = "zxing_preferences_invert_scan";  
-  public static final String KEY_SEARCH_COUNTRY = "zxing_preferences_search_country";
-  public static final String KEY_DISABLE_AUTO_ORIENTATION = "zxing_preferences_orientation";
+  public static final String KEY_INVERT_SCAN = "zxing_preferences_invert_scan";
 
   public static final String KEY_DISABLE_CONTINUOUS_FOCUS = "zxing_preferences_disable_continuous_focus";
   public static final String KEY_DISABLE_EXPOSURE = "zxing_preferences_disable_exposure";
   public static final String KEY_DISABLE_METERING = "zxing_preferences_disable_metering";
   public static final String KEY_DISABLE_BARCODE_SCENE_MODE = "zxing_preferences_disable_barcode_scene_mode";
-  public static final String KEY_AUTO_OPEN_WEB = "zxing_preferences_auto_open_web";
-
-  @Override
-  protected void onCreate(Bundle icicle) {
-    super.onCreate(icicle);
-    getFragmentManager().beginTransaction().replace(android.R.id.content, new PreferencesFragment()).commit();
-  }
-
-  // Apparently this will be necessary when targeting API 19+:
-  /*
-  @Override
-  protected boolean isValidFragment(String fragmentName) {
-    return true;
-  }
-   */
-
 }
diff --git a/src-orig/com/google/zxing/client/android/camera/open/OpenCameraInterface.java b/src/com/google/zxing/client/android/camera/open/OpenCameraInterface.java
index 1f53bdb..134805e 100644
--- a/src-orig/com/google/zxing/client/android/camera/open/OpenCameraInterface.java
+++ b/src/com/google/zxing/client/android/camera/open/OpenCameraInterface.java
@@ -29,21 +29,15 @@ public final class OpenCameraInterface {
   /** For {@link #open(int)}, means no preference for which camera to open. */
   public static final int NO_REQUESTED_CAMERA = -1;
 
-  /**
-   * Opens the requested camera with {@link Camera#open(int)}, if one exists.
-   *
-   * @param cameraId camera ID of the camera to use. A negative value
-   *  or {@link #NO_REQUESTED_CAMERA} means "no preference"
-   * @return handle to {@link Camera} that was opened
-   */
-  public static Camera open(int cameraId) {
-    
+  public static int getCameraId(int requestedId) {
     int numCameras = Camera.getNumberOfCameras();
     if (numCameras == 0) {
       Log.w(TAG, "No cameras!");
-      return null;
+      return -1;
     }
 
+    int cameraId = requestedId;
+
     boolean explicitRequest = cameraId >= 0;
 
     if (!explicitRequest) {
@@ -57,25 +51,34 @@ public final class OpenCameraInterface {
         }
         index++;
       }
-      
+
       cameraId = index;
     }
 
-    Camera camera;
     if (cameraId < numCameras) {
-      Log.i(TAG, "Opening camera #" + cameraId);
-      camera = Camera.open(cameraId);
+      return cameraId;
     } else {
       if (explicitRequest) {
-        Log.w(TAG, "Requested camera does not exist: " + cameraId);
-        camera = null;
+        return -1;
       } else {
-        Log.i(TAG, "No camera facing back; returning camera #0");
-        camera = Camera.open(0);
+        return 0;
       }
     }
-    
-    return camera;
+  }
+  /**
+   * Opens the requested camera with {@link Camera#open(int)}, if one exists.
+   *
+   * @param requestedId camera ID of the camera to use. A negative value
+   *  or {@link #NO_REQUESTED_CAMERA} means "no preference"
+   * @return handle to {@link Camera} that was opened
+   */
+  public static Camera open(int requestedId) {
+    int cameraId = getCameraId(requestedId);
+    if(cameraId == -1) {
+      return null;
+    } else {
+      return Camera.open(cameraId);
+    }
   }
   
 }
diff --git a/src-orig/com/google/zxing/client/android/camera/CameraConfigurationManager.java b/src/com/google/zxing/client/android/camera/CameraConfigurationManager.java
index 6faac7a..e1643af 100644
--- a/src-orig/com/google/zxing/client/android/camera/CameraConfigurationManager.java
+++ b/src/com/google/zxing/client/android/camera/CameraConfigurationManager.java
@@ -23,6 +23,7 @@ import android.hardware.Camera;
 import android.preference.PreferenceManager;
 import android.util.Log;
 import android.view.Display;
+import android.view.Surface;
 import android.view.WindowManager;
 
 import com.google.zxing.client.android.PreferencesActivity;
@@ -77,10 +78,10 @@ final class CameraConfigurationManager {
     initializeTorch(parameters, prefs, safeMode);
 
     CameraConfigurationUtils.setFocus(
-        parameters,
-        prefs.getBoolean(PreferencesActivity.KEY_AUTO_FOCUS, true),
-        prefs.getBoolean(PreferencesActivity.KEY_DISABLE_CONTINUOUS_FOCUS, true),
-        safeMode);
+            parameters,
+            prefs.getBoolean(PreferencesActivity.KEY_AUTO_FOCUS, true),
+            prefs.getBoolean(PreferencesActivity.KEY_DISABLE_CONTINUOUS_FOCUS, true),
+            safeMode);
 
     if (!safeMode) {
       if (prefs.getBoolean(PreferencesActivity.KEY_INVERT_SCAN, false)) {
@@ -105,6 +106,7 @@ final class CameraConfigurationManager {
 
     camera.setParameters(parameters);
 
+
     Camera.Parameters afterParameters = camera.getParameters();
     Camera.Size afterSize = afterParameters.getPreviewSize();
     if (afterSize!= null && (cameraResolution.x != afterSize.width || cameraResolution.y != afterSize.height)) {
@@ -115,6 +117,30 @@ final class CameraConfigurationManager {
     }
   }
 
+  public void setCameraDisplayOrientation(int cameraId, android.hardware.Camera camera) {
+    android.hardware.Camera.CameraInfo info =
+            new android.hardware.Camera.CameraInfo();
+    android.hardware.Camera.getCameraInfo(cameraId, info);
+    int rotation = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay()
+            .getRotation();
+    int degrees = 0;
+    switch (rotation) {
+      case Surface.ROTATION_0: degrees = 0; break;
+      case Surface.ROTATION_90: degrees = 90; break;
+      case Surface.ROTATION_180: degrees = 180; break;
+      case Surface.ROTATION_270: degrees = 270; break;
+    }
+
+    int result;
+    if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {
+      result = (info.orientation + degrees) % 360;
+      result = (360 - result) % 360;  // compensate the mirror
+    } else {  // back-facing
+      result = (info.orientation - degrees + 360) % 360;
+    }
+    camera.setDisplayOrientation(result);
+  }
+
   Point getCameraResolution() {
     return cameraResolution;
   }
diff --git a/src-orig/com/google/zxing/client/android/camera/CameraManager.java b/src/com/google/zxing/client/android/camera/CameraManager.java
index c0caa2b..fd89508 100755
--- a/src-orig/com/google/zxing/client/android/camera/CameraManager.java
+++ b/src/com/google/zxing/client/android/camera/CameraManager.java
@@ -97,7 +97,9 @@ public final class CameraManager {
 
     Camera.Parameters parameters = theCamera.getParameters();
     String parametersFlattened = parameters == null ? null : parameters.flatten(); // Save these, temporarily
+
     try {
+      configManager.setCameraDisplayOrientation(OpenCameraInterface.getCameraId(requestedCameraId), theCamera);
       configManager.setDesiredCameraParameters(theCamera, false);
     } catch (RuntimeException re) {
       // Driver failed
@@ -117,6 +119,8 @@ public final class CameraManager {
       }
     }
 
+
+
   }
 
   public synchronized boolean isOpen() {
diff --git a/src-orig/com/google/zxing/client/android/CaptureActivity.java b/src/com/google/zxing/client/android/CaptureActivity.java
index 35ec55b..283c4ae 100755
--- a/src-orig/com/google/zxing/client/android/CaptureActivity.java
+++ b/src/com/google/zxing/client/android/CaptureActivity.java
@@ -16,58 +16,41 @@
 
 package com.google.zxing.client.android;
 
-import com.google.zxing.BarcodeFormat;
-import com.google.zxing.DecodeHintType;
-import com.google.zxing.Result;
-import com.google.zxing.ResultMetadataType;
-import com.google.zxing.ResultPoint;
-import com.google.zxing.client.android.camera.CameraManager;
-import com.google.zxing.client.android.clipboard.ClipboardInterface;
-import com.google.zxing.client.android.history.HistoryActivity;
-import com.google.zxing.client.android.history.HistoryItem;
-import com.google.zxing.client.android.history.HistoryManager;
-import com.google.zxing.client.android.result.ResultButtonListener;
-import com.google.zxing.client.android.result.ResultHandler;
-import com.google.zxing.client.android.result.ResultHandlerFactory;
-import com.google.zxing.client.android.result.supplement.SupplementalInfoRetriever;
-import com.google.zxing.client.android.share.ShareActivity;
-
+import android.annotation.TargetApi;
 import android.app.Activity;
 import android.app.AlertDialog;
 import android.content.Intent;
-import android.content.SharedPreferences;
 import android.content.pm.ActivityInfo;
 import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
 import android.graphics.Canvas;
 import android.graphics.Paint;
-import android.net.Uri;
+import android.graphics.Point;
+import android.os.Build;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.Message;
 import android.preference.PreferenceManager;
 import android.util.Log;
-import android.util.TypedValue;
+import android.view.Display;
 import android.view.KeyEvent;
-import android.view.Menu;
-import android.view.MenuInflater;
-import android.view.MenuItem;
 import android.view.Surface;
 import android.view.SurfaceHolder;
 import android.view.SurfaceView;
 import android.view.View;
-import android.view.ViewGroup;
 import android.view.Window;
 import android.view.WindowManager;
-import android.widget.ImageView;
+import android.widget.Button;
 import android.widget.TextView;
-import android.widget.Toast;
+
+import com.google.zxing.BarcodeFormat;
+import com.google.zxing.DecodeHintType;
+import com.google.zxing.Result;
+import com.google.zxing.ResultMetadataType;
+import com.google.zxing.ResultPoint;
+import com.google.zxing.client.android.camera.CameraManager;
 
 import java.io.IOException;
-import java.text.DateFormat;
 import java.util.Collection;
-import java.util.Date;
-import java.util.EnumSet;
 import java.util.Map;
 
 /**
@@ -78,39 +61,23 @@ import java.util.Map;
  * @author dswitkin@google.com (Daniel Switkin)
  * @author Sean Owen
  */
+@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
 public final class CaptureActivity extends Activity implements SurfaceHolder.Callback {
 
   private static final String TAG = CaptureActivity.class.getSimpleName();
 
-  private static final long DEFAULT_INTENT_RESULT_DURATION_MS = 1500L;
-  private static final long BULK_MODE_SCAN_DELAY_MS = 1000L;
-
-  private static final String[] ZXING_URLS = { "http://zxing.appspot.com/scan", "zxing://scan/" };
+  private static final long DEFAULT_INTENT_RESULT_DURATION_MS = 0L;
 
-  public static final int HISTORY_REQUEST_CODE = 0x0000bacc;
-
-  private static final Collection<ResultMetadataType> DISPLAYABLE_METADATA_TYPES =
-      EnumSet.of(ResultMetadataType.ISSUE_NUMBER,
-                 ResultMetadataType.SUGGESTED_PRICE,
-                 ResultMetadataType.ERROR_CORRECTION_LEVEL,
-                 ResultMetadataType.POSSIBLE_COUNTRY);
+  public static final java.lang.String ZXING_CAPTURE_LAYOUT_ID_KEY = "ZXING_CAPTURE_LAYOUT_ID_KEY";
 
   private CameraManager cameraManager;
   private CaptureActivityHandler handler;
-  private Result savedResultToShow;
   private ViewfinderView viewfinderView;
   private TextView statusView;
-  private View resultView;
-  private Result lastResult;
   private boolean hasSurface;
-  private boolean copyToClipboard;
-  private IntentSource source;
-  private String sourceUrl;
-  private ScanFromWebPageManager scanFromWebPageManager;
   private Collection<BarcodeFormat> decodeFormats;
   private Map<DecodeHintType,?> decodeHints;
   private String characterSet;
-  private HistoryManager historyManager;
   private InactivityTimer inactivityTimer;
   private BeepManager beepManager;
   private AmbientLightManager ambientLightManager;
@@ -133,7 +100,15 @@ public final class CaptureActivity extends Activity implements SurfaceHolder.Cal
 
     Window window = getWindow();
     window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
-    setContentView(R.layout.zxing_capture);
+
+    // If the resource id with a layout was provided, set up this layout
+    Bundle extras = getIntent().getExtras();
+
+    int zxingCaptureLayoutResourceId = R.layout.zxing_capture;
+    if (extras != null) {
+        zxingCaptureLayoutResourceId = extras.getInt(ZXING_CAPTURE_LAYOUT_ID_KEY, R.layout.zxing_capture);
+    }
+    setContentView (zxingCaptureLayoutResourceId);
 
     hasSurface = false;
     inactivityTimer = new InactivityTimer(this);
@@ -141,15 +116,25 @@ public final class CaptureActivity extends Activity implements SurfaceHolder.Cal
     ambientLightManager = new AmbientLightManager(this);
 
     PreferenceManager.setDefaultValues(this, R.xml.zxing_preferences, false);
+
+    Button cancelButton = (Button) findViewById(R.id.zxing_back_button);
+
+    // Since the layout can be dynamically set by the Intent, cancelButton may not be present
+    if (cancelButton != null) {
+      cancelButton.setOnClickListener(new View.OnClickListener() {
+        @Override
+        public void onClick(View view) {
+          setResult(RESULT_CANCELED);
+          finish();
+        }
+      });
+    }
+
   }
 
   @Override
   protected void onResume() {
     super.onResume();
-    
-    // historyManager must be initialized here to update the history preference
-    historyManager = new HistoryManager(this);
-    historyManager.trimHistory();
 
     // CameraManager must be initialized here, not in onCreate(). This is necessary because we don't
     // want to open the camera driver and measure the screen size if we're going to show the help on
@@ -160,23 +145,23 @@ public final class CaptureActivity extends Activity implements SurfaceHolder.Cal
     viewfinderView = (ViewfinderView) findViewById(R.id.zxing_viewfinder_view);
     viewfinderView.setCameraManager(cameraManager);
 
-    resultView = findViewById(R.id.zxing_result_view);
     statusView = (TextView) findViewById(R.id.zxing_status_view);
 
     handler = null;
-    lastResult = null;
 
-    SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
+    resetStatusView();
 
-    if (prefs.getBoolean(PreferencesActivity.KEY_DISABLE_AUTO_ORIENTATION, true)) {
-      setRequestedOrientation(getCurrentOrientation());
+    SurfaceView surfaceView = (SurfaceView) findViewById(R.id.zxing_preview_view);
+    SurfaceHolder surfaceHolder = surfaceView.getHolder();
+    if (hasSurface) {
+      // The activity was paused but not stopped, so the surface still exists. Therefore
+      // surfaceCreated() won't be called, so init the camera here.
+      initCamera(surfaceHolder);
     } else {
-      setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE);
+      // Install the callback and wait for surfaceCreated() to init the camera.
+      surfaceHolder.addCallback(this);
     }
 
-    resetStatusView();
-
-
     beepManager.updatePrefs();
     ambientLightManager.start(cameraManager);
 
@@ -184,28 +169,40 @@ public final class CaptureActivity extends Activity implements SurfaceHolder.Cal
 
     Intent intent = getIntent();
 
-    copyToClipboard = prefs.getBoolean(PreferencesActivity.KEY_COPY_TO_CLIPBOARD, true)
-        && (intent == null || intent.getBooleanExtra(Intents.Scan.SAVE_HISTORY, true));
-
-    source = IntentSource.NONE;
-    sourceUrl = null;
-    scanFromWebPageManager = null;
     decodeFormats = null;
     characterSet = null;
 
     if (intent != null) {
 
       String action = intent.getAction();
-      String dataString = intent.getDataString();
 
       if (Intents.Scan.ACTION.equals(action)) {
 
         // Scan the formats the intent requested, and return the result to the calling activity.
-        source = IntentSource.NATIVE_APP_INTENT;
         decodeFormats = DecodeFormatManager.parseDecodeFormats(intent);
         decodeHints = DecodeHintManager.parseDecodeHints(intent);
 
-        if (intent.hasExtra(Intents.Scan.WIDTH) && intent.hasExtra(Intents.Scan.HEIGHT)) {
+
+        int orientation = intent.getIntExtra(Intents.Scan.ORIENTATION, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
+        if(orientation == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
+          // Lock to landscape or reverse landscape
+          //noinspection ResourceType
+          setRequestedOrientation(getCurrentOrientation());
+        } else {
+          //noinspection ResourceType
+          setRequestedOrientation(orientation);
+        }
+
+        if (intent.getBooleanExtra(Intents.Scan.WIDE, false)) {
+          WindowManager window = getWindowManager();
+          Display display = window.getDefaultDisplay();
+          Point displaySize = new Point();
+          display.getSize(displaySize);
+
+          int desiredWidth = displaySize.x * 9 / 10;  // 90% width
+          int desiredHeight = Math.min(displaySize.y * 3 / 4, 400);    // 75% height, limit to 400px
+          cameraManager.setManualFramingRect(desiredWidth, desiredHeight);
+        } else if (intent.hasExtra(Intents.Scan.WIDTH) && intent.hasExtra(Intents.Scan.HEIGHT)) {
           int width = intent.getIntExtra(Intents.Scan.WIDTH, 0);
           int height = intent.getIntExtra(Intents.Scan.HEIGHT, 0);
           if (width > 0 && height > 0) {
@@ -219,49 +216,17 @@ public final class CaptureActivity extends Activity implements SurfaceHolder.Cal
             cameraManager.setManualCameraId(cameraId);
           }
         }
-        
+
         String customPromptMessage = intent.getStringExtra(Intents.Scan.PROMPT_MESSAGE);
         if (customPromptMessage != null) {
           statusView.setText(customPromptMessage);
         }
 
-      } else if (dataString != null &&
-                 dataString.contains("http://www.google") &&
-                 dataString.contains("/m/products/scan")) {
-
-        // Scan only products and send the result to mobile Product Search.
-        source = IntentSource.PRODUCT_SEARCH_LINK;
-        sourceUrl = dataString;
-        decodeFormats = DecodeFormatManager.PRODUCT_FORMATS;
-
-      } else if (isZXingURL(dataString)) {
-
-        // Scan formats requested in query string (all formats if none specified).
-        // If a return URL is specified, send the results there. Otherwise, handle it ourselves.
-        source = IntentSource.ZXING_LINK;
-        sourceUrl = dataString;
-        Uri inputUri = Uri.parse(dataString);
-        scanFromWebPageManager = new ScanFromWebPageManager(inputUri);
-        decodeFormats = DecodeFormatManager.parseDecodeFormats(inputUri);
-        // Allow a sub-set of the hints to be specified by the caller.
-        decodeHints = DecodeHintManager.parseDecodeHints(inputUri);
-
       }
 
       characterSet = intent.getStringExtra(Intents.Scan.CHARACTER_SET);
 
     }
-
-    SurfaceView surfaceView = (SurfaceView) findViewById(R.id.zxing_preview_view);
-    SurfaceHolder surfaceHolder = surfaceView.getHolder();
-    if (hasSurface) {
-      // The activity was paused but not stopped, so the surface still exists. Therefore
-      // surfaceCreated() won't be called, so init the camera here.
-      initCamera(surfaceHolder);
-    } else {
-      // Install the callback and wait for surfaceCreated() to init the camera.
-      surfaceHolder.addCallback(this);
-    }
   }
 
   private int getCurrentOrientation() {
@@ -274,18 +239,6 @@ public final class CaptureActivity extends Activity implements SurfaceHolder.Cal
         return ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;
     }
   }
-  
-  private static boolean isZXingURL(String dataString) {
-    if (dataString == null) {
-      return false;
-    }
-    for (String url : ZXING_URLS) {
-      if (dataString.startsWith(url)) {
-        return true;
-      }
-    }
-    return false;
-  }
 
   @Override
   protected void onPause() {
@@ -297,7 +250,6 @@ public final class CaptureActivity extends Activity implements SurfaceHolder.Cal
     ambientLightManager.stop();
     beepManager.close();
     cameraManager.closeDriver();
-    //historyManager = null; // Keep for onActivityResult
     if (!hasSurface) {
       SurfaceView surfaceView = (SurfaceView) findViewById(R.id.zxing_preview_view);
       SurfaceHolder surfaceHolder = surfaceView.getHolder();
@@ -316,16 +268,9 @@ public final class CaptureActivity extends Activity implements SurfaceHolder.Cal
   public boolean onKeyDown(int keyCode, KeyEvent event) {
     switch (keyCode) {
       case KeyEvent.KEYCODE_BACK:
-        if (source == IntentSource.NATIVE_APP_INTENT) {
-          setResult(RESULT_CANCELED);
-          finish();
-          return true;
-        }
-        if ((source == IntentSource.NONE || source == IntentSource.ZXING_LINK) && lastResult != null) {
-          restartPreviewAfterDelay(0L);
-          return true;
-        }
-        break;
+        setResult(RESULT_CANCELED);
+        finish();
+        return true;
       case KeyEvent.KEYCODE_FOCUS:
       case KeyEvent.KEYCODE_CAMERA:
         // Handle these events so they don't launch the Camera app
@@ -342,65 +287,6 @@ public final class CaptureActivity extends Activity implements SurfaceHolder.Cal
   }
 
   @Override
-  public boolean onCreateOptionsMenu(Menu menu) {
-    MenuInflater menuInflater = getMenuInflater();
-    menuInflater.inflate(R.menu.zxing_capture, menu);
-    return super.onCreateOptionsMenu(menu);
-  }
-
-  @Override
-  public boolean onOptionsItemSelected(MenuItem item) {
-    Intent intent = new Intent(Intent.ACTION_VIEW);
-    intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
-    int switchValue = item.getItemId();
-    if(switchValue == R.id.zxing_menu_share) {
-        intent.setClassName(this, ShareActivity.class.getName());
-        startActivity(intent);
-      } else if(switchValue == R.id.zxing_menu_history) {
-        intent.setClassName(this, HistoryActivity.class.getName());
-        startActivityForResult(intent, HISTORY_REQUEST_CODE);
-      } else if(switchValue == R.id.zxing_menu_settings) {
-        intent.setClassName(this, PreferencesActivity.class.getName());
-        startActivity(intent);
-      } else if(switchValue == R.id.zxing_menu_help) {
-        intent.setClassName(this, HelpActivity.class.getName());
-        startActivity(intent);
-      } else {
-        return super.onOptionsItemSelected(item);
-    }
-    return true;
-  }
-
-  @Override
-  public void onActivityResult(int requestCode, int resultCode, Intent intent) {
-    if (resultCode == RESULT_OK) {
-      if (requestCode == HISTORY_REQUEST_CODE) {
-        int itemNumber = intent.getIntExtra(Intents.History.ITEM_NUMBER, -1);
-        if (itemNumber >= 0) {
-          HistoryItem historyItem = historyManager.buildHistoryItem(itemNumber);
-          decodeOrStoreSavedBitmap(null, historyItem.getResult());
-        }
-      }
-    }
-  }
-
-  private void decodeOrStoreSavedBitmap(Bitmap bitmap, Result result) {
-    // Bitmap isn't used yet -- will be used soon
-    if (handler == null) {
-      savedResultToShow = result;
-    } else {
-      if (result != null) {
-        savedResultToShow = result;
-      }
-      if (savedResultToShow != null) {
-        Message message = Message.obtain(handler, R.id.zxing_decode_succeeded, savedResultToShow);
-        handler.sendMessage(message);
-      }
-      savedResultToShow = null;
-    }
-  }
-
-  @Override
   public void surfaceCreated(SurfaceHolder holder) {
     if (holder == null) {
       Log.e(TAG, "*** WARNING *** surfaceCreated() gave us a null surface!");
@@ -425,47 +311,19 @@ public final class CaptureActivity extends Activity implements SurfaceHolder.Cal
    * A valid barcode has been found, so give an indication of success and show the results.
    *
    * @param rawResult The contents of the barcode.
-   * @param scaleFactor amount by which thumbnail was scaled
    * @param barcode   A greyscale bitmap of the camera data which was decoded.
    */
   public void handleDecode(Result rawResult, Bitmap barcode, float scaleFactor) {
     inactivityTimer.onActivity();
-    lastResult = rawResult;
-    ResultHandler resultHandler = ResultHandlerFactory.makeResultHandler(this, rawResult);
 
     boolean fromLiveScan = barcode != null;
     if (fromLiveScan) {
-      historyManager.addHistoryItem(rawResult, resultHandler);
       // Then not from history, so beep/vibrate and we have an image to draw on
       beepManager.playBeepSoundAndVibrate();
       drawResultPoints(barcode, scaleFactor, rawResult);
     }
 
-    switch (source) {
-      case NATIVE_APP_INTENT:
-      case PRODUCT_SEARCH_LINK:
-        handleDecodeExternally(rawResult, resultHandler, barcode);
-        break;
-      case ZXING_LINK:
-        if (scanFromWebPageManager == null || !scanFromWebPageManager.isScanFromWebPage()) {
-          handleDecodeInternally(rawResult, resultHandler, barcode);
-        } else {
-          handleDecodeExternally(rawResult, resultHandler, barcode);
-        }
-        break;
-      case NONE:
-        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
-        if (fromLiveScan && prefs.getBoolean(PreferencesActivity.KEY_BULK_MODE, false)) {
-          Toast.makeText(getApplicationContext(),
-                         getResources().getString(R.string.zxing_msg_bulk_mode_scanned) + " (" + rawResult.getText() + ')',
-                         Toast.LENGTH_SHORT).show();
-          // Wait a moment or else it will scan the same barcode continuously about 3 times
-          restartPreviewAfterDelay(BULK_MODE_SCAN_DELAY_MS);
-        } else {
-          handleDecodeInternally(rawResult, resultHandler, barcode);
-        }
-        break;
-    }
+    handleDecodeExternally(rawResult, barcode);
   }
 
   /**
@@ -511,180 +369,51 @@ public final class CaptureActivity extends Activity implements SurfaceHolder.Cal
     }
   }
 
-  // Put up our own UI for how to handle the decoded contents.
-  private void handleDecodeInternally(Result rawResult, ResultHandler resultHandler, Bitmap barcode) {
-
-    CharSequence displayContents = resultHandler.getDisplayContents();
-
-    if (copyToClipboard && !resultHandler.areContentsSecure()) {
-      ClipboardInterface.setText(displayContents, this);
-    }
-
-    SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
-
-    if (resultHandler.getDefaultButtonID() != null && prefs.getBoolean(PreferencesActivity.KEY_AUTO_OPEN_WEB, false)) {
-      resultHandler.handleButtonPress(resultHandler.getDefaultButtonID());
-      return;
-    }
-
-    statusView.setVisibility(View.GONE);
-    viewfinderView.setVisibility(View.GONE);
-    resultView.setVisibility(View.VISIBLE);
-
-    ImageView barcodeImageView = (ImageView) findViewById(R.id.zxing_barcode_image_view);
-    if (barcode == null) {
-      barcodeImageView.setImageBitmap(BitmapFactory.decodeResource(getResources(),
-          R.drawable.zxing_launcher_icon));
-    } else {
-      barcodeImageView.setImageBitmap(barcode);
-    }
-
-    TextView formatTextView = (TextView) findViewById(R.id.zxing_format_text_view);
-    formatTextView.setText(rawResult.getBarcodeFormat().toString());
-
-    TextView typeTextView = (TextView) findViewById(R.id.zxing_type_text_view);
-    typeTextView.setText(resultHandler.getType().toString());
-
-    DateFormat formatter = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT);
-    TextView timeTextView = (TextView) findViewById(R.id.zxing_time_text_view);
-    timeTextView.setText(formatter.format(new Date(rawResult.getTimestamp())));
-
-
-    TextView metaTextView = (TextView) findViewById(R.id.zxing_meta_text_view);
-    View metaTextViewLabel = findViewById(R.id.zxing_meta_text_view_label);
-    metaTextView.setVisibility(View.GONE);
-    metaTextViewLabel.setVisibility(View.GONE);
-    Map<ResultMetadataType,Object> metadata = rawResult.getResultMetadata();
-    if (metadata != null) {
-      StringBuilder metadataText = new StringBuilder(20);
-      for (Map.Entry<ResultMetadataType,Object> entry : metadata.entrySet()) {
-        if (DISPLAYABLE_METADATA_TYPES.contains(entry.getKey())) {
-          metadataText.append(entry.getValue()).append('\n');
-        }
-      }
-      if (metadataText.length() > 0) {
-        metadataText.setLength(metadataText.length() - 1);
-        metaTextView.setText(metadataText);
-        metaTextView.setVisibility(View.VISIBLE);
-        metaTextViewLabel.setVisibility(View.VISIBLE);
-      }
-    }
-
-    TextView contentsTextView = (TextView) findViewById(R.id.zxing_contents_text_view);
-    contentsTextView.setText(displayContents);
-    int scaledSize = Math.max(22, 32 - displayContents.length() / 4);
-    contentsTextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, scaledSize);
-
-    TextView supplementTextView = (TextView) findViewById(R.id.zxing_contents_supplement_text_view);
-    supplementTextView.setText("");
-    supplementTextView.setOnClickListener(null);
-    if (PreferenceManager.getDefaultSharedPreferences(this).getBoolean(
-        PreferencesActivity.KEY_SUPPLEMENTAL, true)) {
-      SupplementalInfoRetriever.maybeInvokeRetrieval(supplementTextView,
-                                                     resultHandler.getResult(),
-                                                     historyManager,
-                                                     this);
-    }
-
-    int buttonCount = resultHandler.getButtonCount();
-    ViewGroup buttonView = (ViewGroup) findViewById(R.id.zxing_result_button_view);
-    buttonView.requestFocus();
-    for (int x = 0; x < ResultHandler.MAX_BUTTON_COUNT; x++) {
-      TextView button = (TextView) buttonView.getChildAt(x);
-      if (x < buttonCount) {
-        button.setVisibility(View.VISIBLE);
-        button.setText(resultHandler.getButtonText(x));
-        button.setOnClickListener(new ResultButtonListener(resultHandler, x));
-      } else {
-        button.setVisibility(View.GONE);
-      }
-    }
-
-  }
-
   // Briefly show the contents of the barcode, then handle the result outside Barcode Scanner.
-  private void handleDecodeExternally(Result rawResult, ResultHandler resultHandler, Bitmap barcode) {
+  private void handleDecodeExternally(Result rawResult, Bitmap barcode) {
 
     if (barcode != null) {
       viewfinderView.drawResultBitmap(barcode);
     }
 
-    long resultDurationMS;
-    if (getIntent() == null) {
-      resultDurationMS = DEFAULT_INTENT_RESULT_DURATION_MS;
-    } else {
-      resultDurationMS = getIntent().getLongExtra(Intents.Scan.RESULT_DISPLAY_DURATION_MS,
+    long resultDurationMS = getIntent().getLongExtra(Intents.Scan.RESULT_DISPLAY_DURATION_MS,
                                                   DEFAULT_INTENT_RESULT_DURATION_MS);
-    }
 
-    if (resultDurationMS > 0) {
-      String rawResultString = String.valueOf(rawResult);
-      if (rawResultString.length() > 32) {
-        rawResultString = rawResultString.substring(0, 32) + " ...";
-      }
-      statusView.setText(getString(resultHandler.getDisplayTitle()) + " : " + rawResultString);
-    }
-
-    if (copyToClipboard && !resultHandler.areContentsSecure()) {
-      CharSequence text = resultHandler.getDisplayContents();
-      ClipboardInterface.setText(text, this);
+    // Hand back whatever action they requested - this can be changed to Intents.Scan.ACTION when
+    // the deprecated intent is retired.
+    Intent intent = new Intent(getIntent().getAction());
+    intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
+    intent.putExtra(Intents.Scan.RESULT, rawResult.toString());
+    intent.putExtra(Intents.Scan.RESULT_FORMAT, rawResult.getBarcodeFormat().toString());
+    byte[] rawBytes = rawResult.getRawBytes();
+    if (rawBytes != null && rawBytes.length > 0) {
+      intent.putExtra(Intents.Scan.RESULT_BYTES, rawBytes);
     }
-
-    if (source == IntentSource.NATIVE_APP_INTENT) {
-      
-      // Hand back whatever action they requested - this can be changed to Intents.Scan.ACTION when
-      // the deprecated intent is retired.
-      Intent intent = new Intent(getIntent().getAction());
-      intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
-      intent.putExtra(Intents.Scan.RESULT, rawResult.toString());
-      intent.putExtra(Intents.Scan.RESULT_FORMAT, rawResult.getBarcodeFormat().toString());
-      byte[] rawBytes = rawResult.getRawBytes();
-      if (rawBytes != null && rawBytes.length > 0) {
-        intent.putExtra(Intents.Scan.RESULT_BYTES, rawBytes);
+    Map<ResultMetadataType,?> metadata = rawResult.getResultMetadata();
+    if (metadata != null) {
+      if (metadata.containsKey(ResultMetadataType.UPC_EAN_EXTENSION)) {
+        intent.putExtra(Intents.Scan.RESULT_UPC_EAN_EXTENSION,
+                        metadata.get(ResultMetadataType.UPC_EAN_EXTENSION).toString());
       }
-      Map<ResultMetadataType,?> metadata = rawResult.getResultMetadata();
-      if (metadata != null) {
-        if (metadata.containsKey(ResultMetadataType.UPC_EAN_EXTENSION)) {
-          intent.putExtra(Intents.Scan.RESULT_UPC_EAN_EXTENSION,
-                          metadata.get(ResultMetadataType.UPC_EAN_EXTENSION).toString());
-        }
-        Number orientation = (Number) metadata.get(ResultMetadataType.ORIENTATION);
-        if (orientation != null) {
-          intent.putExtra(Intents.Scan.RESULT_ORIENTATION, orientation.intValue());
-        }
-        String ecLevel = (String) metadata.get(ResultMetadataType.ERROR_CORRECTION_LEVEL);
-        if (ecLevel != null) {
-          intent.putExtra(Intents.Scan.RESULT_ERROR_CORRECTION_LEVEL, ecLevel);
-        }
-        @SuppressWarnings("unchecked")
-        Iterable<byte[]> byteSegments = (Iterable<byte[]>) metadata.get(ResultMetadataType.BYTE_SEGMENTS);
-        if (byteSegments != null) {
-          int i = 0;
-          for (byte[] byteSegment : byteSegments) {
-            intent.putExtra(Intents.Scan.RESULT_BYTE_SEGMENTS_PREFIX + i, byteSegment);
-            i++;
-          }
-        }
+      Number orientation = (Number) metadata.get(ResultMetadataType.ORIENTATION);
+      if (orientation != null) {
+        intent.putExtra(Intents.Scan.RESULT_ORIENTATION, orientation.intValue());
       }
-      sendReplyMessage(R.id.zxing_return_scan_result, intent, resultDurationMS);
-      
-    } else if (source == IntentSource.PRODUCT_SEARCH_LINK) {
-      
-      // Reformulate the URL which triggered us into a query, so that the request goes to the same
-      // TLD as the scan URL.
-      int end = sourceUrl.lastIndexOf("/scan");
-      String replyURL = sourceUrl.substring(0, end) + "?q=" + resultHandler.getDisplayContents() + "&source=zxing";      
-      sendReplyMessage(R.id.zxing_launch_product_query, replyURL, resultDurationMS);
-      
-    } else if (source == IntentSource.ZXING_LINK) {
-
-      if (scanFromWebPageManager != null && scanFromWebPageManager.isScanFromWebPage()) {
-        String replyURL = scanFromWebPageManager.buildReplyURL(rawResult, resultHandler);
-        scanFromWebPageManager = null;
-        sendReplyMessage(R.id.zxing_launch_product_query, replyURL, resultDurationMS);
+      String ecLevel = (String) metadata.get(ResultMetadataType.ERROR_CORRECTION_LEVEL);
+      if (ecLevel != null) {
+        intent.putExtra(Intents.Scan.RESULT_ERROR_CORRECTION_LEVEL, ecLevel);
+      }
+      @SuppressWarnings("unchecked")
+      Iterable<byte[]> byteSegments = (Iterable<byte[]>) metadata.get(ResultMetadataType.BYTE_SEGMENTS);
+      if (byteSegments != null) {
+        int i = 0;
+        for (byte[] byteSegment : byteSegments) {
+          intent.putExtra(Intents.Scan.RESULT_BYTE_SEGMENTS_PREFIX + i, byteSegment);
+          i++;
+        }
       }
-      
     }
+    sendReplyMessage(R.id.zxing_return_scan_result, intent, resultDurationMS);
   }
   
   private void sendReplyMessage(int id, Object arg, long delayMS) {
@@ -712,7 +441,6 @@ public final class CaptureActivity extends Activity implements SurfaceHolder.Cal
       if (handler == null) {
         handler = new CaptureActivityHandler(this, decodeFormats, decodeHints, characterSet, cameraManager);
       }
-      decodeOrStoreSavedBitmap(null, null);
     } catch (IOException ioe) {
       Log.w(TAG, ioe);
       displayFrameworkBugMessageAndExit();
@@ -733,19 +461,10 @@ public final class CaptureActivity extends Activity implements SurfaceHolder.Cal
     builder.show();
   }
 
-  public void restartPreviewAfterDelay(long delayMS) {
-    if (handler != null) {
-      handler.sendEmptyMessageDelayed(R.id.zxing_restart_preview, delayMS);
-    }
-    resetStatusView();
-  }
-
   private void resetStatusView() {
-    resultView.setVisibility(View.GONE);
     statusView.setText(R.string.zxing_msg_default_status);
     statusView.setVisibility(View.VISIBLE);
     viewfinderView.setVisibility(View.VISIBLE);
-    lastResult = null;
   }
 
   public void drawViewfinder() {
diff --git a/src-orig/com/google/zxing/client/android/DecodeHandler.java b/src/com/google/zxing/client/android/DecodeHandler.java
index b6a5561..eb8c0ca 100644
--- a/src-orig/com/google/zxing/client/android/DecodeHandler.java
+++ b/src/com/google/zxing/client/android/DecodeHandler.java
@@ -21,7 +21,6 @@ import com.google.zxing.BinaryBitmap;
 import com.google.zxing.DecodeHintType;
 import com.google.zxing.MultiFormatReader;
 import com.google.zxing.PlanarYUVLuminanceSource;
-import com.google.zxing.ReaderException;
 import com.google.zxing.Result;
 import com.google.zxing.common.HybridBinarizer;
 
@@ -53,12 +52,13 @@ final class DecodeHandler extends Handler {
     if (!running) {
       return;
     }
-    int switchValue = message.what;
-    if(switchValue == R.id.zxing_decode) {
-        decode((byte[]) message.obj, message.arg1, message.arg2);
-      } else if(switchValue == R.id.zxing_quit) {
-        running = false;
-        Looper.myLooper().quit();
+    if (message.what == R.id.zxing_decode) {
+      decode((byte[]) message.obj, message.arg1, message.arg2);
+
+    } else if (message.what == R.id.zxing_quit) {
+      running = false;
+      Looper.myLooper().quit();
+
     }
   }
 
@@ -78,7 +78,7 @@ final class DecodeHandler extends Handler {
       BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));
       try {
         rawResult = multiFormatReader.decodeWithState(bitmap);
-      } catch (ReaderException re) {
+      } catch (Exception e) {
         // continue
       } finally {
         multiFormatReader.reset();
diff --git a/src-orig/com/google/zxing/client/android/Intents.java b/src/com/google/zxing/client/android/Intents.java
index 6e59e80..ce4ea63 100755
--- a/src-orig/com/google/zxing/client/android/Intents.java
+++ b/src/com/google/zxing/client/android/Intents.java
@@ -102,6 +102,15 @@ public final class Intents {
     public static final String HEIGHT = "SCAN_HEIGHT";
 
     /**
+     * Boolen parameter to indicate that a wide scanning rectangle should be used.
+     */
+    public static final String WIDE = "SCAN_WIDE";
+
+
+    public static final String ORIENTATION = "SCAN_ORIENTATION";
+
+
+    /**
      * Desired duration in milliseconds for which to pause after a successful scan before
      * returning to the calling intent. Specified as a long, not an integer!
      * For example: 1000L, not 1000.
@@ -119,7 +128,7 @@ public final class Intents {
      * of the app which requested the scan via
      * {@link android.app.Activity#startActivityForResult(android.content.Intent, int)}
      * The barcodes contents can be retrieved with
-     * {@link android.content.Intent#getStringExtra(String)}. 
+     * {@link android.content.Intent#getStringExtra(String)}.
      * If the user presses Back, the result code will be {@link android.app.Activity#RESULT_CANCELED}.
      */
     public static final String RESULT = "SCAN_RESULT";
@@ -165,114 +174,7 @@ public final class Intents {
      */
     public static final String RESULT_BYTE_SEGMENTS_PREFIX = "SCAN_RESULT_BYTE_SEGMENTS_";
 
-    /**
-     * Setting this to false will not save scanned codes in the history. Specified as a {@code boolean}.
-     */
-    public static final String SAVE_HISTORY = "SAVE_HISTORY";
-
     private Scan() {
     }
   }
-
-  public static final class History {
-
-    public static final String ITEM_NUMBER = "ITEM_NUMBER";
-
-    private History() {
-    }
-  }
-
-  public static final class Encode {
-    /**
-     * Send this intent to encode a piece of data as a QR code and display it full screen, so
-     * that another person can scan the barcode from your screen.
-     */
-    public static final String ACTION = "com.google.zxing.client.android.ENCODE";
-
-    /**
-     * The data to encode. Use {@link android.content.Intent#putExtra(String, String)} or
-     * {@link android.content.Intent#putExtra(String, android.os.Bundle)}, 
-     * depending on the type and format specified. Non-QR Code formats should
-     * just use a String here. For QR Code, see Contents for details.
-     */
-    public static final String DATA = "ENCODE_DATA";
-
-    /**
-     * The type of data being supplied if the format is QR Code. Use
-     * {@link android.content.Intent#putExtra(String, String)} with one of {@link Contents.Type}.
-     */
-    public static final String TYPE = "ENCODE_TYPE";
-
-    /**
-     * The barcode format to be displayed. If this isn't specified or is blank,
-     * it defaults to QR Code. Use {@link android.content.Intent#putExtra(String, String)}, where
-     * format is one of {@link com.google.zxing.BarcodeFormat}.
-     */
-    public static final String FORMAT = "ENCODE_FORMAT";
-
-    /**
-     * Normally the contents of the barcode are displayed to the user in a TextView. Setting this
-     * boolean to false will hide that TextView, showing only the encode barcode.
-     */
-    public static final String SHOW_CONTENTS = "ENCODE_SHOW_CONTENTS";
-
-    private Encode() {
-    }
-  }
-
-  public static final class SearchBookContents {
-    /**
-     * Use Google Book Search to search the contents of the book provided.
-     */
-    public static final String ACTION = "com.google.zxing.client.android.SEARCH_BOOK_CONTENTS";
-
-    /**
-     * The book to search, identified by ISBN number.
-     */
-    public static final String ISBN = "ISBN";
-
-    /**
-     * An optional field which is the text to search for.
-     */
-    public static final String QUERY = "QUERY";
-
-    private SearchBookContents() {
-    }
-  }
-
-  public static final class WifiConnect {
-    /**
-     * Internal intent used to trigger connection to a wi-fi network.
-     */
-    public static final String ACTION = "com.google.zxing.client.android.WIFI_CONNECT";
-
-    /**
-     * The network to connect to, all the configuration provided here.
-     */
-    public static final String SSID = "SSID";
-
-    /**
-     * The network to connect to, all the configuration provided here.
-     */
-    public static final String TYPE = "TYPE";
-
-    /**
-     * The network to connect to, all the configuration provided here.
-     */
-    public static final String PASSWORD = "PASSWORD";
-
-    private WifiConnect() {
-    }
-  }
-
-  public static final class Share {
-    /**
-     * Give the user a choice of items to encode as a barcode, then render it as a QR Code and
-     * display onscreen for a friend to scan with their phone.
-     */
-    public static final String ACTION = "com.google.zxing.client.android.SHARE";
-
-    private Share() {
-    }
-  }
 }
diff --git a/src-orig/com/google/zxing/client/android/DecodeThread.java b/src/com/google/zxing/client/android/DecodeThread.java
index fab4039..90f4285 100755
--- a/src-orig/com/google/zxing/client/android/DecodeThread.java
+++ b/src/com/google/zxing/client/android/DecodeThread.java
@@ -61,29 +61,6 @@ final class DecodeThread extends Thread {
       hints.putAll(baseHints);
     }
 
-    // The prefs can't change while the thread is running, so pick them up once here.
-    if (decodeFormats == null || decodeFormats.isEmpty()) {
-      SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(activity);
-      decodeFormats = EnumSet.noneOf(BarcodeFormat.class);
-      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_1D_PRODUCT, true)) {
-        decodeFormats.addAll(DecodeFormatManager.PRODUCT_FORMATS);
-      }
-      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_1D_INDUSTRIAL, true)) {
-        decodeFormats.addAll(DecodeFormatManager.INDUSTRIAL_FORMATS);
-      }
-      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_QR, true)) {
-        decodeFormats.addAll(DecodeFormatManager.QR_CODE_FORMATS);
-      }
-      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_DATA_MATRIX, true)) {
-        decodeFormats.addAll(DecodeFormatManager.DATA_MATRIX_FORMATS);
-      }
-      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_AZTEC, false)) {
-        decodeFormats.addAll(DecodeFormatManager.AZTEC_FORMATS);
-      }
-      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_PDF417, false)) {
-        decodeFormats.addAll(DecodeFormatManager.PDF417_FORMATS);
-      }
-    }
     hints.put(DecodeHintType.POSSIBLE_FORMATS, decodeFormats);
 
     if (characterSet != null) {
